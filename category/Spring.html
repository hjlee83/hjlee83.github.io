<!DOCTYPE html><html><head><script>
                            (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-N6X882T');
              </script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>정년퇴직을 꿈꾸는 개발자</title><link rel="icon" href="/favicon.ico"/><meta name="description" content="기술을 익히고 공유합니다."/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/654792c85b915c123aa8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/654792c85b915c123aa8.css" data-n-g=""/><link rel="preload" href="/_next/static/css/1f8120f5b4600661fbe6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1f8120f5b4600661fbe6.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-99ad68a3f1273cf1678f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.a6402fb70cc88f6f61b0.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.7af247b43e14ac66e88e.js" as="script"/><link rel="preload" href="/_next/static/chunks/f658db493258337e4ee0c0d6b56e2d9169f0c93b.88d5ad5fd990ced1c5da.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-b0db3a5d0ee96813b162.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/category/%5Bid%5D-72bc47d3aaee4c938797.js" as="script"/></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-N6X882T" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><header style="border-bottom:1px solid #eee"><div class="wrapper"><a class="SiteHeader_wrap__1H66r" href="/"><span>정년퇴직을 꿈꾸는 개발자</span></a></div></header><div class="pageContent"><div class="wrapper"><div class="CategoryBanner_wrap__gIxAp"><div class="CategoryBanner_bgItem__1seew"></div><div class="CategoryBanner_dimmed__1zVrT"><div class="CategoryBanner_contentLayout__3RUlu"><div class="CategoryBanner_smallText__ty9Ld"></div><div class="CategoryBanner_text__1mE08">Spring</div></div></div></div><section class="content-layout"><div class="list"><div class="ListModule_listModule__dCXP5"><span class="ListModule_postMeta__2ybhZ">2021. 01. 11.</span><a href="/2"><h2 class="ListModule_postLink__1mnu9">@NotNull vs @NotEmpty vs @NotBlank</h2><p class="ListModule_postDescription__3GHvU">크롬 확장 플러그인을 개발하면서 배운 점을 공유합니다.</p></a></div></div><aside class="page-aside"><section class="category"><strong style="color:#2ac1bc;font-size:18px">categories</strong><ul><li><a href="/category/%EA%B8%B0%ED%83%80">기타<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/category/Bean%20Validation">Bean Validation<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/category/Spring">Spring<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/category/Java">Java<!-- --> (<!-- -->1<!-- -->)</a></li></ul></section><section class="recent-posts"><strong style="color:#2ac1bc;font-size:18px">Recent Posts</strong><ul><li><a href="/2">- <!-- -->@NotNull vs @NotEmpty vs @NotBlank</a></li><li><a href="/1">- <!-- -->첫 블로그</a></li></ul></section></aside></section></div></div><footer class="SiteFooter_siteFooter__1mQRw"><div class="wrapper">© hjlee83</div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"category":"Spring","allPostsData":[{"id":"2","title":"@NotNull vs @NotEmpty vs @NotBlank","description":"@NotNull, @NotEmpty, @NotBlank 를 언제 사용해야하는지 설명합니다.","date":"2021. 01. 11.","category":["Bean Validation","Spring","Java"],"content":"\n## 시작하면서\n\nspring 을 하면서 validation 에 대해 얘기해보려합니다.\n\n웹 서비스를 만들면서 다양하게 검증을 사용할 일이 생깁니다.\n\n웹프로그램을 만들다보면 프리젠테이션 계층부터 지속성 계층까지 반복적인 유효성검사는 코드의 품질을 떨어뜨리고 오류발생을 높입니다.\n그래서  [JSR-303](https://jcp.org/en/jsr/detail?id=303) 이 나왔습니다.\n\n그리고 자바 8이 나오고나서 자바8에 맞추어 bean validation 2.0 에 맞게 [JSR-380](https://jcp.org/en/jsr/detail?id=380) 이 나왔습니다.\n\n\u003e JSR 은 자바스펙요구서 (Java Specification Request)\n\n이런 Bean Validation 을 사용하면 쉽게 검증을 적용할수 있습니다.\n\n하지만 그동안 코드리뷰를 하면서 NotNull, NotEmpty 그리고 NotBlank 를 혼용하는 분들을 종종 발견하곤 합니다.\n\n그래서 해당 내용을 정리하려합니다.\n\n## @NotNull\n\n```java\npackage com.example.code.validation;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.InitBinder;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@SpringBootApplication\npublic class ValidationApplication {\n\n    @InitBinder\n    public void initBinder(WebDataBinder binder) {\n        binder.initDirectFieldAccess();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(ValidationApplication.class, args);\n    }\n\n    @GetMapping(\"/hello\")\n    public String helloName(HelloRequest helloRequest) {\n\n        return helloRequest.getMessage();\n    }\n\n    public static class HelloRequest {\n\n       private String name;\n\n        public String getMessage() {\n            return String.format(\"안녕 %s\", name);\n        }\n    }\n}\n```\n\n/hello 을 호출하게 되면 \"안녕 이름\" 이 호출되는 간단한 컨트롤러입니다.\n\u003e request 에 setter 를 안넣는 방법은 조졸두님 [블로그](https://jojoldu.tistory.com/407) 를 참고해주세요.\n\n```java\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.ResultActions;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@WebMvcTest\nclass HelloControllerTest {\n\n    @Autowired\n    MockMvc mvc;\n\n    @Test\n    @DisplayName(\"hello 컨트롤러가 잘 되는지 확인\")\n    void helloTest1() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n        );\n\n        // then\n        resultActions\n                .andExpect(status().isOk())\n                .andExpect(content().string(\"안녕 null\"));\n\n    }\n}\n```\n\n테스트 코드입니다.  \n테스트는 통과과 되겠지만 결과 데이터는 안녕 null 입니다.  \nname 이 null 이 되면 안될것 같습니다.\n\n코드를 고쳐보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotNull(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private String name;\n\n    public String getMessage() {\n        return String.format(\"hello %s\", name);\n    }\n}\n```\n\n(1) HelloRequest 에 @NotNull 을 추가합니다.\n\n다시 수행하면 예상과 달리 또 통과가 되는데요.  \n이유는 validation 어노테이션을 체크할수 있는 장치가 추가로 필요하기 때문입니다.\n\n```java\npublic class ValidationApplication {\n    \n    // ...\n    @GetMapping(\"/hello\")\n    public String helloName(@Valid HelloRequest helloRequest) { // (1)\n\n        return helloRequest.getMessage();\n    }\n    // ...\n}\n```\n\n(1) @Valid 어노테이션을 추가하였습니다.\n\n다시 수행하면 예상처럼 테스트가 실패가 됩니다.  \n테스트를 성공시키도록 수정해보겠습니다.\n\n```java\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.MvcResult;\nimport org.springframework.test.web.servlet.ResultActions;\nimport org.springframework.validation.BindException;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.tuple;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@WebMvcTest\nclass HelloControllerTest {\n\n    // ...\n    \n    @Test\n    @DisplayName(\"hello 컨트롤러에 파라미터를 전달 안하면 name validation 이 작동한다\") // (1)\n    void helloTest1() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n        );\n\n        // then\n        MvcResult mvcResult = resultActions\n                .andExpect(status().isBadRequest())\n                .andReturn();\n\n        assertThat(((BindException) mvcResult.getResolvedException()).getBindingResult().getFieldErrors()) // (2)\n                .extracting(\"field\", \"defaultMessage\")\n                .containsExactlyInAnyOrder(\n                        tuple(\"name\", \"이름은 빈값일 수 없습니다.\")\n                );\n    }\n}\n```\n\n(1) 테스트 이름을 변경합니다.  \n(2) 바인딩 에러를 잡아서 검증합니다.\n\n이제 통과를 할것입니다.  \n우리가 원하던대로 null 을 막았습니다.\n\nname 에 빈값이 들어가면 어떻게 될까요?  \n저는 빈값도 예외가 나오길 원합니다.\n\n테스트를 추가해보겠습니다.\n\n```java\n\n@WebMvcTest\nclass HelloControllerTest {\n    \n    // ...\n    \n    @Test\n    @DisplayName(\"hello 컨트롤러에 name 값을 빈값으로 전달하면 name validation 이 작동한다\")\n    void helloTest2() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n                .param(\"name\", \"\") // (1)\n        );\n\n        // then\n        MvcResult mvcResult = resultActions\n                .andExpect(status().isBadRequest())\n                .andReturn();\n\n        assertThat(((BindException) mvcResult.getResolvedException()).getBindingResult().getFieldErrors())\n                .extracting(\"field\", \"defaultMessage\")\n                .containsExactlyInAnyOrder(\n                        tuple(\"name\", \"이름은 빈값일 수 없습니다.\")\n                );\n    }\n}\n```\n\n(1) 먼저 작성한 테스트와 동일하지만 파라미터로 name 이 추가되었습니다.\n\n다시 수행하면 예상과 다르게 status 가 isOk 가 되면서 테스트가 실패하게 됩니다. 우리는 @NotNull 을 넣었는데 왜 통과가 되는것일까요?\n\nNotNull 의 javaDoc 을 보면\n\n\u003e The annotated element must not be null. Accepts any type.\n\n이렇게 되어있습니다.  \nnull 만 체크하는용도입니다.\n\n## NotBlank\n\n코드를 수정해보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotBlank(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private String name;\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n```\n\n(1) @NotBlank 로 변경해보겠습니다.\n\n테스트를 재수행해보면 통과하는것을 알 수 있습니다.\n\nNotBlank 의 javaDoc 을 보면\n\n\u003e The annotated element must not be null and must contain at least one non-whitespace character.  \n\u003e Accepts CharSequence.\n\n이렇게 되어있습니다.  \nNotBlank 는 null 과 빈문자열을 체크하네요.\n\n## NotEmpty\n\n그동안 api 는 안녕 철수. 안녕 영희 같이 한명을 대상으로 했습니다.\n\n근데 저는 안녕 철수, 영희 처럼 2명을 대상으로 하고 싶어졌습니다.\n\n아래처럼 변경해보죠.\n\n```java\npublic static class HelloRequest {\n\n    @NotBlank(message = \"이름은 빈값일 수 없습니다.\")\n    private List\u003cString\u003e name; // (1)\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n```\n\n리스트로 변경해봅니다.  \n테스트를 재수행하면 아래와 같은 오류를 내뿜으면서 다 깨집니다.\n\n```\nNo validator could be found for constraint 'javax.validation.constraints.NotBlank' validating type 'java.util.List\u003cjava.lang.String\u003e'. Check configuration for 'name'\n```\n\nNotBlank 를 List 에 쓸수 없다 라고 나오네요.\n\n다시 코드를 변경해보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotNull(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private List\u003cString\u003e name;\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n```\n\n(1) NotNull 로 다시 변경했습니다.\n\n테스트를 재수행하니 helloTest1은 통과되고 helloTest2는 isOk를 내보내면서 실패했네요.\n\n@NotNull 로는 빈배열을 체크할수 없습니다.\n\n코드를 수정해보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotEmpty(message = \"이름은 빈값일 수 없습니다.\") // (1) \n    private List\u003cString\u003e name;\n\n    public String getMessage() {\n        return String.format(\"hello %s\", name);\n    }\n}\n```\n\n(1) NotEmpty 로 변경했습니다.\n\n테스트를 재수행하니 통과되었습니다.\n\nNotEmpty 의 javaDoc 을 보면\n\n\u003e The annotated element must not be null nor empty.  \n\u003e Supported types are:    \n\u003e CharSequence (length of character sequence is evaluated)  \n\u003e Collection (collection size is evaluated)  \n\u003e Map (map size is evaluated)  \n\u003e Array (array length is evaluated)\n\n이렇게 되어있습니다.    \nNotEmpty 는 null 과 비어있는지 체크를 합니다.\n\n## 결론\n\n검증하려는 필드가 List 인가?\n\nyes → @NotEmpty\n\nno → 아래문항으로\n\n검증하려는 필드가 String 인가?\n\nyes → @NotBlank\n\nno → @NotNull\n\n읽어주셔서 감사합니다."}],"recentPosts":[{"id":"2","title":"@NotNull vs @NotEmpty vs @NotBlank","description":"@NotNull, @NotEmpty, @NotBlank 를 언제 사용해야하는지 설명합니다.","date":"2021. 01. 11.","category":["Bean Validation","Spring","Java"],"content":"\n## 시작하면서\n\nspring 을 하면서 validation 에 대해 얘기해보려합니다.\n\n웹 서비스를 만들면서 다양하게 검증을 사용할 일이 생깁니다.\n\n웹프로그램을 만들다보면 프리젠테이션 계층부터 지속성 계층까지 반복적인 유효성검사는 코드의 품질을 떨어뜨리고 오류발생을 높입니다.\n그래서  [JSR-303](https://jcp.org/en/jsr/detail?id=303) 이 나왔습니다.\n\n그리고 자바 8이 나오고나서 자바8에 맞추어 bean validation 2.0 에 맞게 [JSR-380](https://jcp.org/en/jsr/detail?id=380) 이 나왔습니다.\n\n\u003e JSR 은 자바스펙요구서 (Java Specification Request)\n\n이런 Bean Validation 을 사용하면 쉽게 검증을 적용할수 있습니다.\n\n하지만 그동안 코드리뷰를 하면서 NotNull, NotEmpty 그리고 NotBlank 를 혼용하는 분들을 종종 발견하곤 합니다.\n\n그래서 해당 내용을 정리하려합니다.\n\n## @NotNull\n\n```java\npackage com.example.code.validation;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.InitBinder;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@SpringBootApplication\npublic class ValidationApplication {\n\n    @InitBinder\n    public void initBinder(WebDataBinder binder) {\n        binder.initDirectFieldAccess();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(ValidationApplication.class, args);\n    }\n\n    @GetMapping(\"/hello\")\n    public String helloName(HelloRequest helloRequest) {\n\n        return helloRequest.getMessage();\n    }\n\n    public static class HelloRequest {\n\n       private String name;\n\n        public String getMessage() {\n            return String.format(\"안녕 %s\", name);\n        }\n    }\n}\n```\n\n/hello 을 호출하게 되면 \"안녕 이름\" 이 호출되는 간단한 컨트롤러입니다.\n\u003e request 에 setter 를 안넣는 방법은 조졸두님 [블로그](https://jojoldu.tistory.com/407) 를 참고해주세요.\n\n```java\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.ResultActions;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@WebMvcTest\nclass HelloControllerTest {\n\n    @Autowired\n    MockMvc mvc;\n\n    @Test\n    @DisplayName(\"hello 컨트롤러가 잘 되는지 확인\")\n    void helloTest1() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n        );\n\n        // then\n        resultActions\n                .andExpect(status().isOk())\n                .andExpect(content().string(\"안녕 null\"));\n\n    }\n}\n```\n\n테스트 코드입니다.  \n테스트는 통과과 되겠지만 결과 데이터는 안녕 null 입니다.  \nname 이 null 이 되면 안될것 같습니다.\n\n코드를 고쳐보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotNull(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private String name;\n\n    public String getMessage() {\n        return String.format(\"hello %s\", name);\n    }\n}\n```\n\n(1) HelloRequest 에 @NotNull 을 추가합니다.\n\n다시 수행하면 예상과 달리 또 통과가 되는데요.  \n이유는 validation 어노테이션을 체크할수 있는 장치가 추가로 필요하기 때문입니다.\n\n```java\npublic class ValidationApplication {\n    \n    // ...\n    @GetMapping(\"/hello\")\n    public String helloName(@Valid HelloRequest helloRequest) { // (1)\n\n        return helloRequest.getMessage();\n    }\n    // ...\n}\n```\n\n(1) @Valid 어노테이션을 추가하였습니다.\n\n다시 수행하면 예상처럼 테스트가 실패가 됩니다.  \n테스트를 성공시키도록 수정해보겠습니다.\n\n```java\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.MvcResult;\nimport org.springframework.test.web.servlet.ResultActions;\nimport org.springframework.validation.BindException;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.tuple;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@WebMvcTest\nclass HelloControllerTest {\n\n    // ...\n    \n    @Test\n    @DisplayName(\"hello 컨트롤러에 파라미터를 전달 안하면 name validation 이 작동한다\") // (1)\n    void helloTest1() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n        );\n\n        // then\n        MvcResult mvcResult = resultActions\n                .andExpect(status().isBadRequest())\n                .andReturn();\n\n        assertThat(((BindException) mvcResult.getResolvedException()).getBindingResult().getFieldErrors()) // (2)\n                .extracting(\"field\", \"defaultMessage\")\n                .containsExactlyInAnyOrder(\n                        tuple(\"name\", \"이름은 빈값일 수 없습니다.\")\n                );\n    }\n}\n```\n\n(1) 테스트 이름을 변경합니다.  \n(2) 바인딩 에러를 잡아서 검증합니다.\n\n이제 통과를 할것입니다.  \n우리가 원하던대로 null 을 막았습니다.\n\nname 에 빈값이 들어가면 어떻게 될까요?  \n저는 빈값도 예외가 나오길 원합니다.\n\n테스트를 추가해보겠습니다.\n\n```java\n\n@WebMvcTest\nclass HelloControllerTest {\n    \n    // ...\n    \n    @Test\n    @DisplayName(\"hello 컨트롤러에 name 값을 빈값으로 전달하면 name validation 이 작동한다\")\n    void helloTest2() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n                .param(\"name\", \"\") // (1)\n        );\n\n        // then\n        MvcResult mvcResult = resultActions\n                .andExpect(status().isBadRequest())\n                .andReturn();\n\n        assertThat(((BindException) mvcResult.getResolvedException()).getBindingResult().getFieldErrors())\n                .extracting(\"field\", \"defaultMessage\")\n                .containsExactlyInAnyOrder(\n                        tuple(\"name\", \"이름은 빈값일 수 없습니다.\")\n                );\n    }\n}\n```\n\n(1) 먼저 작성한 테스트와 동일하지만 파라미터로 name 이 추가되었습니다.\n\n다시 수행하면 예상과 다르게 status 가 isOk 가 되면서 테스트가 실패하게 됩니다. 우리는 @NotNull 을 넣었는데 왜 통과가 되는것일까요?\n\nNotNull 의 javaDoc 을 보면\n\n\u003e The annotated element must not be null. Accepts any type.\n\n이렇게 되어있습니다.  \nnull 만 체크하는용도입니다.\n\n## NotBlank\n\n코드를 수정해보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotBlank(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private String name;\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n```\n\n(1) @NotBlank 로 변경해보겠습니다.\n\n테스트를 재수행해보면 통과하는것을 알 수 있습니다.\n\nNotBlank 의 javaDoc 을 보면\n\n\u003e The annotated element must not be null and must contain at least one non-whitespace character.  \n\u003e Accepts CharSequence.\n\n이렇게 되어있습니다.  \nNotBlank 는 null 과 빈문자열을 체크하네요.\n\n## NotEmpty\n\n그동안 api 는 안녕 철수. 안녕 영희 같이 한명을 대상으로 했습니다.\n\n근데 저는 안녕 철수, 영희 처럼 2명을 대상으로 하고 싶어졌습니다.\n\n아래처럼 변경해보죠.\n\n```java\npublic static class HelloRequest {\n\n    @NotBlank(message = \"이름은 빈값일 수 없습니다.\")\n    private List\u003cString\u003e name; // (1)\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n```\n\n리스트로 변경해봅니다.  \n테스트를 재수행하면 아래와 같은 오류를 내뿜으면서 다 깨집니다.\n\n```\nNo validator could be found for constraint 'javax.validation.constraints.NotBlank' validating type 'java.util.List\u003cjava.lang.String\u003e'. Check configuration for 'name'\n```\n\nNotBlank 를 List 에 쓸수 없다 라고 나오네요.\n\n다시 코드를 변경해보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotNull(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private List\u003cString\u003e name;\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n```\n\n(1) NotNull 로 다시 변경했습니다.\n\n테스트를 재수행하니 helloTest1은 통과되고 helloTest2는 isOk를 내보내면서 실패했네요.\n\n@NotNull 로는 빈배열을 체크할수 없습니다.\n\n코드를 수정해보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotEmpty(message = \"이름은 빈값일 수 없습니다.\") // (1) \n    private List\u003cString\u003e name;\n\n    public String getMessage() {\n        return String.format(\"hello %s\", name);\n    }\n}\n```\n\n(1) NotEmpty 로 변경했습니다.\n\n테스트를 재수행하니 통과되었습니다.\n\nNotEmpty 의 javaDoc 을 보면\n\n\u003e The annotated element must not be null nor empty.  \n\u003e Supported types are:    \n\u003e CharSequence (length of character sequence is evaluated)  \n\u003e Collection (collection size is evaluated)  \n\u003e Map (map size is evaluated)  \n\u003e Array (array length is evaluated)\n\n이렇게 되어있습니다.    \nNotEmpty 는 null 과 비어있는지 체크를 합니다.\n\n## 결론\n\n검증하려는 필드가 List 인가?\n\nyes → @NotEmpty\n\nno → 아래문항으로\n\n검증하려는 필드가 String 인가?\n\nyes → @NotBlank\n\nno → @NotNull\n\n읽어주셔서 감사합니다."},{"id":"1","title":"첫 블로그","description":"2021년 블로그를 시작과 인사말","date":"2021. 01. 01.","category":["기타"],"content":"\n2021년을 맞이하여 블로그를 꾸준히 운영을 해보려합니다.\n\n제가 필요한 기술들과   \n회사에서 접했던 문제들을 공유하려 합니다.\n\n일단 블로그는 next 로 틀만 만들고 차츰차츰 꾸밀거에요.\n\n블로그를 꾸미는 과정도 시리즈로 제공을 해볼게요.\n\n방문해주셔서 감사합니다."}],"categories":[{"id":"기타","count":1},{"id":"Bean Validation","count":1},{"id":"Spring","count":1},{"id":"Java","count":1}]},"__N_SSG":true},"page":"/category/[id]","query":{"id":"Spring"},"buildId":"oiDe4_E9aSbfPloesV44j","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-250f16924c392849df26.js"></script><script src="/_next/static/chunks/main-99ad68a3f1273cf1678f.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.a6402fb70cc88f6f61b0.js" async=""></script><script src="/_next/static/chunks/commons.7af247b43e14ac66e88e.js" async=""></script><script src="/_next/static/chunks/f658db493258337e4ee0c0d6b56e2d9169f0c93b.88d5ad5fd990ced1c5da.js" async=""></script><script src="/_next/static/chunks/pages/_app-b0db3a5d0ee96813b162.js" async=""></script><script src="/_next/static/chunks/pages/category/%5Bid%5D-72bc47d3aaee4c938797.js" async=""></script><script src="/_next/static/oiDe4_E9aSbfPloesV44j/_buildManifest.js" async=""></script><script src="/_next/static/oiDe4_E9aSbfPloesV44j/_ssgManifest.js" async=""></script></body></html>