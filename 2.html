<!DOCTYPE html><html><head><script>
                            (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-N6X882T');
              </script><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><meta name="description" content="기술을 익히고 공유합니다."/><title>@NotNull vs @NotEmpty vs @NotBlank</title><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/a990cb67e36dc1b2b2c2.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a990cb67e36dc1b2b2c2.css" data-n-g=""/><link rel="preload" href="/_next/static/css/bd10d098c87e1bf0260e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/bd10d098c87e1bf0260e.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-99ad68a3f1273cf1678f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.a6402fb70cc88f6f61b0.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.7af247b43e14ac66e88e.js" as="script"/><link rel="preload" href="/_next/static/chunks/f658db493258337e4ee0c0d6b56e2d9169f0c93b.88d5ad5fd990ced1c5da.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-ea914611bb791faec916.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/%5Bid%5D-ee51f05b8ea1a0f56175.js" as="script"/></head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-N6X882T" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div id="__next"><header style="border-bottom:1px solid #eee"><div class="wrapper"><a class="SiteHeader_wrap__1H66r" href="/"><span>정년퇴직을 꿈꾸는 개발자</span></a></div></header><div class="pageContent"><div class="wrapper"><div class="CategoryBanner_wrap__gIxAp"><div class="CategoryBanner_bgItem__1seew"></div><div class="CategoryBanner_dimmed__1zVrT"><div class="CategoryBanner_contentLayout__3RUlu"><div class="CategoryBanner_smallText__ty9Ld">2021. 01. 11.</div><div class="CategoryBanner_text__1mE08">@NotNull vs @NotEmpty vs @NotBlank</div></div></div></div><section class="content-layout"><div class="list"><div class="PostBody_wrap__24yP1"><div class="PostBody_markdown__2ts2T"><h2>시작하면서</h2>
<p>spring 을 하면서 validation 에 대해 얘기해보려합니다.</p>
<p>웹 서비스를 만들면서 다양하게 검증을 사용할 일이 생깁니다.</p>
<p>웹프로그램을 만들다보면 프리젠테이션 계층부터 지속성 계층까지 반복적인 유효성검사는 코드의 품질을 떨어뜨리고 오류발생을 높입니다.
그래서  <a href="https://jcp.org/en/jsr/detail?id=303">JSR-303</a> 이 나왔습니다.</p>
<p>그리고 자바 8이 나오고나서 자바8에 맞추어 bean validation 2.0 에 맞게 <a href="https://jcp.org/en/jsr/detail?id=380">JSR-380</a> 이 나왔습니다.</p>
<blockquote>
<p>JSR 은 자바스펙요구서 (Java Specification Request)</p>
</blockquote>
<p>이런 Bean Validation 을 사용하면 쉽게 검증을 적용할수 있습니다.</p>
<p>하지만 그동안 코드리뷰를 하면서 NotNull, NotEmpty 그리고 NotBlank 를 혼용하는 분들을 종종 발견하곤 합니다.</p>
<p>그래서 해당 내용을 정리하려합니다.</p>
<h2>@NotNull</h2>
<pre><code class="language-java">package com.example.code.validation;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.InitBinder;
import org.springframework.web.bind.annotation.RestController;

@RestController
@SpringBootApplication
public class ValidationApplication {

    @InitBinder
    public void initBinder(WebDataBinder binder) {
        binder.initDirectFieldAccess();
    }

    public static void main(String[] args) {
        SpringApplication.run(ValidationApplication.class, args);
    }

    @GetMapping("/hello")
    public String helloName(HelloRequest helloRequest) {

        return helloRequest.getMessage();
    }

    public static class HelloRequest {

       private String name;

        public String getMessage() {
            return String.format("안녕 %s", name);
        }
    }
}
</code></pre>
<p>/hello 을 호출하게 되면 "안녕 이름" 이 호출되는 간단한 컨트롤러입니다.</p>
<blockquote>
<p>request 에 setter 를 안넣는 방법은 조졸두님 <a href="https://jojoldu.tistory.com/407">블로그</a> 를 참고해주세요.</p>
</blockquote>
<pre><code class="language-java">import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultActions;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest
class HelloControllerTest {

    @Autowired
    MockMvc mvc;

    @Test
    @DisplayName("hello 컨트롤러가 잘 되는지 확인")
    void helloTest1() throws Exception {

        // when
        ResultActions resultActions = mvc.perform(get("/hello")
        );

        // then
        resultActions
                .andExpect(status().isOk())
                .andExpect(content().string("안녕 null"));

    }
}
</code></pre>
<p>테스트 코드입니다.<br>
테스트는 통과과 되겠지만 결과 데이터는 안녕 null 입니다.<br>
name 이 null 이 되면 안될것 같습니다.</p>
<p>코드를 고쳐보겠습니다.</p>
<pre><code class="language-java">public static class HelloRequest {

    @NotNull(message = "이름은 빈값일 수 없습니다.") // (1)
    private String name;

    public String getMessage() {
        return String.format("hello %s", name);
    }
}
</code></pre>
<p>(1) HelloRequest 에 @NotNull 을 추가합니다.</p>
<p>다시 수행하면 예상과 달리 또 통과가 되는데요.<br>
이유는 validation 어노테이션을 체크할수 있는 장치가 추가로 필요하기 때문입니다.</p>
<pre><code class="language-java">public class ValidationApplication {
    
    // ...
    @GetMapping("/hello")
    public String helloName(@Valid HelloRequest helloRequest) { // (1)

        return helloRequest.getMessage();
    }
    // ...
}
</code></pre>
<p>(1) @Valid 어노테이션을 추가하였습니다.</p>
<p>다시 수행하면 예상처럼 테스트가 실패가 됩니다.<br>
테스트를 성공시키도록 수정해보겠습니다.</p>
<pre><code class="language-java">import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.ResultActions;
import org.springframework.validation.BindException;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.tuple;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@WebMvcTest
class HelloControllerTest {

    // ...
    
    @Test
    @DisplayName("hello 컨트롤러에 파라미터를 전달 안하면 name validation 이 작동한다") // (1)
    void helloTest1() throws Exception {

        // when
        ResultActions resultActions = mvc.perform(get("/hello")
        );

        // then
        MvcResult mvcResult = resultActions
                .andExpect(status().isBadRequest())
                .andReturn();

        assertThat(((BindException) mvcResult.getResolvedException()).getBindingResult().getFieldErrors()) // (2)
                .extracting("field", "defaultMessage")
                .containsExactlyInAnyOrder(
                        tuple("name", "이름은 빈값일 수 없습니다.")
                );
    }
}
</code></pre>
<p>(1) 테스트 이름을 변경합니다.<br>
(2) 바인딩 에러를 잡아서 검증합니다.</p>
<p>이제 통과를 할것입니다.<br>
우리가 원하던대로 null 을 막았습니다.</p>
<p>name 에 빈값이 들어가면 어떻게 될까요?<br>
저는 빈값도 예외가 나오길 원합니다.</p>
<p>테스트를 추가해보겠습니다.</p>
<pre><code class="language-java">
@WebMvcTest
class HelloControllerTest {
    
    // ...
    
    @Test
    @DisplayName("hello 컨트롤러에 name 값을 빈값으로 전달하면 name validation 이 작동한다")
    void helloTest2() throws Exception {

        // when
        ResultActions resultActions = mvc.perform(get("/hello")
                .param("name", "") // (1)
        );

        // then
        MvcResult mvcResult = resultActions
                .andExpect(status().isBadRequest())
                .andReturn();

        assertThat(((BindException) mvcResult.getResolvedException()).getBindingResult().getFieldErrors())
                .extracting("field", "defaultMessage")
                .containsExactlyInAnyOrder(
                        tuple("name", "이름은 빈값일 수 없습니다.")
                );
    }
}
</code></pre>
<p>(1) 먼저 작성한 테스트와 동일하지만 파라미터로 name 이 추가되었습니다.</p>
<p>다시 수행하면 예상과 다르게 status 가 isOk 가 되면서 테스트가 실패하게 됩니다. 우리는 @NotNull 을 넣었는데 왜 통과가 되는것일까요?</p>
<p>NotNull 의 javaDoc 을 보면</p>
<blockquote>
<p>The annotated element must not be null. Accepts any type.</p>
</blockquote>
<p>이렇게 되어있습니다.<br>
null 만 체크하는용도입니다.</p>
<h2>NotBlank</h2>
<p>코드를 수정해보겠습니다.</p>
<pre><code class="language-java">public static class HelloRequest {

    @NotBlank(message = "이름은 빈값일 수 없습니다.") // (1)
    private String name;

    public String getMessage() {
        return String.format("안녕 %s", name);
    }
}
</code></pre>
<p>(1) @NotBlank 로 변경해보겠습니다.</p>
<p>테스트를 재수행해보면 통과하는것을 알 수 있습니다.</p>
<p>NotBlank 의 javaDoc 을 보면</p>
<blockquote>
<p>The annotated element must not be null and must contain at least one non-whitespace character.<br>
Accepts CharSequence.</p>
</blockquote>
<p>이렇게 되어있습니다.<br>
NotBlank 는 null 과 빈문자열을 체크하네요.</p>
<h2>NotEmpty</h2>
<p>그동안 api 는 안녕 철수. 안녕 영희 같이 한명을 대상으로 했습니다.</p>
<p>근데 저는 안녕 철수, 영희 처럼 2명을 대상으로 하고 싶어졌습니다.</p>
<p>아래처럼 변경해보죠.</p>
<pre><code class="language-java">public static class HelloRequest {

    @NotBlank(message = "이름은 빈값일 수 없습니다.")
    private List&#x3C;String> name; // (1)

    public String getMessage() {
        return String.format("안녕 %s", name);
    }
}
</code></pre>
<p>리스트로 변경해봅니다.<br>
테스트를 재수행하면 아래와 같은 오류를 내뿜으면서 다 깨집니다.</p>
<pre><code>No validator could be found for constraint 'javax.validation.constraints.NotBlank' validating type 'java.util.List&#x3C;java.lang.String>'. Check configuration for 'name'
</code></pre>
<p>NotBlank 를 List 에 쓸수 없다 라고 나오네요.</p>
<p>다시 코드를 변경해보겠습니다.</p>
<pre><code class="language-java">public static class HelloRequest {

    @NotNull(message = "이름은 빈값일 수 없습니다.") // (1)
    private List&#x3C;String> name;

    public String getMessage() {
        return String.format("안녕 %s", name);
    }
}
</code></pre>
<p>(1) NotNull 로 다시 변경했습니다.</p>
<p>테스트를 재수행하니 helloTest1은 통과되고 helloTest2는 isOk를 내보내면서 실패했네요.</p>
<p>@NotNull 로는 빈배열을 체크할수 없습니다.</p>
<p>코드를 수정해보겠습니다.</p>
<pre><code class="language-java">public static class HelloRequest {

    @NotEmpty(message = "이름은 빈값일 수 없습니다.") // (1) 
    private List&#x3C;String> name;

    public String getMessage() {
        return String.format("hello %s", name);
    }
}
</code></pre>
<p>(1) NotEmpty 로 변경했습니다.</p>
<p>테스트를 재수행하니 통과되었습니다.</p>
<p>NotEmpty 의 javaDoc 을 보면</p>
<blockquote>
<p>The annotated element must not be null nor empty.<br>
Supported types are:<br>
CharSequence (length of character sequence is evaluated)<br>
Collection (collection size is evaluated)<br>
Map (map size is evaluated)<br>
Array (array length is evaluated)</p>
</blockquote>
<p>이렇게 되어있습니다.<br>
NotEmpty 는 null 과 비어있는지 체크를 합니다.</p>
<h2>결론</h2>
<p>검증하려는 필드가 List 인가?</p>
<p>yes → @NotEmpty</p>
<p>no → 아래문항으로</p>
<p>검증하려는 필드가 String 인가?</p>
<p>yes → @NotBlank</p>
<p>no → @NotNull</p>
<p>읽어주셔서 감사합니다.</p>
</div></div></div><aside class="page-aside"><section class="category"><strong style="color:#2ac1bc;font-size:18px">categories</strong><ul><li><a href="/category/%EA%B8%B0%ED%83%80">기타<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/category/Bean%20Validation">Bean Validation<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/category/Spring">Spring<!-- --> (<!-- -->1<!-- -->)</a></li><li><a href="/category/Java">Java<!-- --> (<!-- -->1<!-- -->)</a></li></ul></section><section class="recent-posts"><strong style="color:#2ac1bc;font-size:18px">Recent Posts</strong><ul><li><a href="/2">- <!-- -->@NotNull vs @NotEmpty vs @NotBlank</a></li><li><a href="/1">- <!-- -->첫 블로그</a></li></ul></section></aside></section></div></div><footer class="SiteFooter_siteFooter__1mQRw"><div class="wrapper">© hjlee83</div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"2","title":"@NotNull vs @NotEmpty vs @NotBlank","description":"@NotNull, @NotEmpty, @NotBlank 를 언제 사용해야하는지 설명합니다.","date":"2021. 01. 11.","category":["Bean Validation","Spring","Java"],"content":"\u003ch2\u003e시작하면서\u003c/h2\u003e\n\u003cp\u003espring 을 하면서 validation 에 대해 얘기해보려합니다.\u003c/p\u003e\n\u003cp\u003e웹 서비스를 만들면서 다양하게 검증을 사용할 일이 생깁니다.\u003c/p\u003e\n\u003cp\u003e웹프로그램을 만들다보면 프리젠테이션 계층부터 지속성 계층까지 반복적인 유효성검사는 코드의 품질을 떨어뜨리고 오류발생을 높입니다.\n그래서  \u003ca href=\"https://jcp.org/en/jsr/detail?id=303\"\u003eJSR-303\u003c/a\u003e 이 나왔습니다.\u003c/p\u003e\n\u003cp\u003e그리고 자바 8이 나오고나서 자바8에 맞추어 bean validation 2.0 에 맞게 \u003ca href=\"https://jcp.org/en/jsr/detail?id=380\"\u003eJSR-380\u003c/a\u003e 이 나왔습니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eJSR 은 자바스펙요구서 (Java Specification Request)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e이런 Bean Validation 을 사용하면 쉽게 검증을 적용할수 있습니다.\u003c/p\u003e\n\u003cp\u003e하지만 그동안 코드리뷰를 하면서 NotNull, NotEmpty 그리고 NotBlank 를 혼용하는 분들을 종종 발견하곤 합니다.\u003c/p\u003e\n\u003cp\u003e그래서 해당 내용을 정리하려합니다.\u003c/p\u003e\n\u003ch2\u003e@NotNull\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage com.example.code.validation;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.InitBinder;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@SpringBootApplication\npublic class ValidationApplication {\n\n    @InitBinder\n    public void initBinder(WebDataBinder binder) {\n        binder.initDirectFieldAccess();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(ValidationApplication.class, args);\n    }\n\n    @GetMapping(\"/hello\")\n    public String helloName(HelloRequest helloRequest) {\n\n        return helloRequest.getMessage();\n    }\n\n    public static class HelloRequest {\n\n       private String name;\n\n        public String getMessage() {\n            return String.format(\"안녕 %s\", name);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e/hello 을 호출하게 되면 \"안녕 이름\" 이 호출되는 간단한 컨트롤러입니다.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003erequest 에 setter 를 안넣는 방법은 조졸두님 \u003ca href=\"https://jojoldu.tistory.com/407\"\u003e블로그\u003c/a\u003e 를 참고해주세요.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.ResultActions;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@WebMvcTest\nclass HelloControllerTest {\n\n    @Autowired\n    MockMvc mvc;\n\n    @Test\n    @DisplayName(\"hello 컨트롤러가 잘 되는지 확인\")\n    void helloTest1() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n        );\n\n        // then\n        resultActions\n                .andExpect(status().isOk())\n                .andExpect(content().string(\"안녕 null\"));\n\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e테스트 코드입니다.\u003cbr\u003e\n테스트는 통과과 되겠지만 결과 데이터는 안녕 null 입니다.\u003cbr\u003e\nname 이 null 이 되면 안될것 같습니다.\u003c/p\u003e\n\u003cp\u003e코드를 고쳐보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static class HelloRequest {\n\n    @NotNull(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private String name;\n\n    public String getMessage() {\n        return String.format(\"hello %s\", name);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(1) HelloRequest 에 @NotNull 을 추가합니다.\u003c/p\u003e\n\u003cp\u003e다시 수행하면 예상과 달리 또 통과가 되는데요.\u003cbr\u003e\n이유는 validation 어노테이션을 체크할수 있는 장치가 추가로 필요하기 때문입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class ValidationApplication {\n    \n    // ...\n    @GetMapping(\"/hello\")\n    public String helloName(@Valid HelloRequest helloRequest) { // (1)\n\n        return helloRequest.getMessage();\n    }\n    // ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(1) @Valid 어노테이션을 추가하였습니다.\u003c/p\u003e\n\u003cp\u003e다시 수행하면 예상처럼 테스트가 실패가 됩니다.\u003cbr\u003e\n테스트를 성공시키도록 수정해보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003eimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.MvcResult;\nimport org.springframework.test.web.servlet.ResultActions;\nimport org.springframework.validation.BindException;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.tuple;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@WebMvcTest\nclass HelloControllerTest {\n\n    // ...\n    \n    @Test\n    @DisplayName(\"hello 컨트롤러에 파라미터를 전달 안하면 name validation 이 작동한다\") // (1)\n    void helloTest1() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n        );\n\n        // then\n        MvcResult mvcResult = resultActions\n                .andExpect(status().isBadRequest())\n                .andReturn();\n\n        assertThat(((BindException) mvcResult.getResolvedException()).getBindingResult().getFieldErrors()) // (2)\n                .extracting(\"field\", \"defaultMessage\")\n                .containsExactlyInAnyOrder(\n                        tuple(\"name\", \"이름은 빈값일 수 없습니다.\")\n                );\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(1) 테스트 이름을 변경합니다.\u003cbr\u003e\n(2) 바인딩 에러를 잡아서 검증합니다.\u003c/p\u003e\n\u003cp\u003e이제 통과를 할것입니다.\u003cbr\u003e\n우리가 원하던대로 null 을 막았습니다.\u003c/p\u003e\n\u003cp\u003ename 에 빈값이 들어가면 어떻게 될까요?\u003cbr\u003e\n저는 빈값도 예외가 나오길 원합니다.\u003c/p\u003e\n\u003cp\u003e테스트를 추가해보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003e\n@WebMvcTest\nclass HelloControllerTest {\n    \n    // ...\n    \n    @Test\n    @DisplayName(\"hello 컨트롤러에 name 값을 빈값으로 전달하면 name validation 이 작동한다\")\n    void helloTest2() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n                .param(\"name\", \"\") // (1)\n        );\n\n        // then\n        MvcResult mvcResult = resultActions\n                .andExpect(status().isBadRequest())\n                .andReturn();\n\n        assertThat(((BindException) mvcResult.getResolvedException()).getBindingResult().getFieldErrors())\n                .extracting(\"field\", \"defaultMessage\")\n                .containsExactlyInAnyOrder(\n                        tuple(\"name\", \"이름은 빈값일 수 없습니다.\")\n                );\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(1) 먼저 작성한 테스트와 동일하지만 파라미터로 name 이 추가되었습니다.\u003c/p\u003e\n\u003cp\u003e다시 수행하면 예상과 다르게 status 가 isOk 가 되면서 테스트가 실패하게 됩니다. 우리는 @NotNull 을 넣었는데 왜 통과가 되는것일까요?\u003c/p\u003e\n\u003cp\u003eNotNull 의 javaDoc 을 보면\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe annotated element must not be null. Accepts any type.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e이렇게 되어있습니다.\u003cbr\u003e\nnull 만 체크하는용도입니다.\u003c/p\u003e\n\u003ch2\u003eNotBlank\u003c/h2\u003e\n\u003cp\u003e코드를 수정해보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static class HelloRequest {\n\n    @NotBlank(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private String name;\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(1) @NotBlank 로 변경해보겠습니다.\u003c/p\u003e\n\u003cp\u003e테스트를 재수행해보면 통과하는것을 알 수 있습니다.\u003c/p\u003e\n\u003cp\u003eNotBlank 의 javaDoc 을 보면\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe annotated element must not be null and must contain at least one non-whitespace character.\u003cbr\u003e\nAccepts CharSequence.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e이렇게 되어있습니다.\u003cbr\u003e\nNotBlank 는 null 과 빈문자열을 체크하네요.\u003c/p\u003e\n\u003ch2\u003eNotEmpty\u003c/h2\u003e\n\u003cp\u003e그동안 api 는 안녕 철수. 안녕 영희 같이 한명을 대상으로 했습니다.\u003c/p\u003e\n\u003cp\u003e근데 저는 안녕 철수, 영희 처럼 2명을 대상으로 하고 싶어졌습니다.\u003c/p\u003e\n\u003cp\u003e아래처럼 변경해보죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static class HelloRequest {\n\n    @NotBlank(message = \"이름은 빈값일 수 없습니다.\")\n    private List\u0026#x3C;String\u003e name; // (1)\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e리스트로 변경해봅니다.\u003cbr\u003e\n테스트를 재수행하면 아래와 같은 오류를 내뿜으면서 다 깨집니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eNo validator could be found for constraint 'javax.validation.constraints.NotBlank' validating type 'java.util.List\u0026#x3C;java.lang.String\u003e'. Check configuration for 'name'\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotBlank 를 List 에 쓸수 없다 라고 나오네요.\u003c/p\u003e\n\u003cp\u003e다시 코드를 변경해보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static class HelloRequest {\n\n    @NotNull(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private List\u0026#x3C;String\u003e name;\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(1) NotNull 로 다시 변경했습니다.\u003c/p\u003e\n\u003cp\u003e테스트를 재수행하니 helloTest1은 통과되고 helloTest2는 isOk를 내보내면서 실패했네요.\u003c/p\u003e\n\u003cp\u003e@NotNull 로는 빈배열을 체크할수 없습니다.\u003c/p\u003e\n\u003cp\u003e코드를 수정해보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static class HelloRequest {\n\n    @NotEmpty(message = \"이름은 빈값일 수 없습니다.\") // (1) \n    private List\u0026#x3C;String\u003e name;\n\n    public String getMessage() {\n        return String.format(\"hello %s\", name);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(1) NotEmpty 로 변경했습니다.\u003c/p\u003e\n\u003cp\u003e테스트를 재수행하니 통과되었습니다.\u003c/p\u003e\n\u003cp\u003eNotEmpty 의 javaDoc 을 보면\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe annotated element must not be null nor empty.\u003cbr\u003e\nSupported types are:\u003cbr\u003e\nCharSequence (length of character sequence is evaluated)\u003cbr\u003e\nCollection (collection size is evaluated)\u003cbr\u003e\nMap (map size is evaluated)\u003cbr\u003e\nArray (array length is evaluated)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e이렇게 되어있습니다.\u003cbr\u003e\nNotEmpty 는 null 과 비어있는지 체크를 합니다.\u003c/p\u003e\n\u003ch2\u003e결론\u003c/h2\u003e\n\u003cp\u003e검증하려는 필드가 List 인가?\u003c/p\u003e\n\u003cp\u003eyes → @NotEmpty\u003c/p\u003e\n\u003cp\u003eno → 아래문항으로\u003c/p\u003e\n\u003cp\u003e검증하려는 필드가 String 인가?\u003c/p\u003e\n\u003cp\u003eyes → @NotBlank\u003c/p\u003e\n\u003cp\u003eno → @NotNull\u003c/p\u003e\n\u003cp\u003e읽어주셔서 감사합니다.\u003c/p\u003e\n"},"recentPosts":[{"id":"2","title":"@NotNull vs @NotEmpty vs @NotBlank","description":"@NotNull, @NotEmpty, @NotBlank 를 언제 사용해야하는지 설명합니다.","date":"2021. 01. 11.","category":["Bean Validation","Spring","Java"],"content":"\n## 시작하면서\n\nspring 을 하면서 validation 에 대해 얘기해보려합니다.\n\n웹 서비스를 만들면서 다양하게 검증을 사용할 일이 생깁니다.\n\n웹프로그램을 만들다보면 프리젠테이션 계층부터 지속성 계층까지 반복적인 유효성검사는 코드의 품질을 떨어뜨리고 오류발생을 높입니다.\n그래서  [JSR-303](https://jcp.org/en/jsr/detail?id=303) 이 나왔습니다.\n\n그리고 자바 8이 나오고나서 자바8에 맞추어 bean validation 2.0 에 맞게 [JSR-380](https://jcp.org/en/jsr/detail?id=380) 이 나왔습니다.\n\n\u003e JSR 은 자바스펙요구서 (Java Specification Request)\n\n이런 Bean Validation 을 사용하면 쉽게 검증을 적용할수 있습니다.\n\n하지만 그동안 코드리뷰를 하면서 NotNull, NotEmpty 그리고 NotBlank 를 혼용하는 분들을 종종 발견하곤 합니다.\n\n그래서 해당 내용을 정리하려합니다.\n\n## @NotNull\n\n```java\npackage com.example.code.validation;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.InitBinder;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@SpringBootApplication\npublic class ValidationApplication {\n\n    @InitBinder\n    public void initBinder(WebDataBinder binder) {\n        binder.initDirectFieldAccess();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(ValidationApplication.class, args);\n    }\n\n    @GetMapping(\"/hello\")\n    public String helloName(HelloRequest helloRequest) {\n\n        return helloRequest.getMessage();\n    }\n\n    public static class HelloRequest {\n\n       private String name;\n\n        public String getMessage() {\n            return String.format(\"안녕 %s\", name);\n        }\n    }\n}\n```\n\n/hello 을 호출하게 되면 \"안녕 이름\" 이 호출되는 간단한 컨트롤러입니다.\n\u003e request 에 setter 를 안넣는 방법은 조졸두님 [블로그](https://jojoldu.tistory.com/407) 를 참고해주세요.\n\n```java\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.ResultActions;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@WebMvcTest\nclass HelloControllerTest {\n\n    @Autowired\n    MockMvc mvc;\n\n    @Test\n    @DisplayName(\"hello 컨트롤러가 잘 되는지 확인\")\n    void helloTest1() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n        );\n\n        // then\n        resultActions\n                .andExpect(status().isOk())\n                .andExpect(content().string(\"안녕 null\"));\n\n    }\n}\n```\n\n테스트 코드입니다.  \n테스트는 통과과 되겠지만 결과 데이터는 안녕 null 입니다.  \nname 이 null 이 되면 안될것 같습니다.\n\n코드를 고쳐보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotNull(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private String name;\n\n    public String getMessage() {\n        return String.format(\"hello %s\", name);\n    }\n}\n```\n\n(1) HelloRequest 에 @NotNull 을 추가합니다.\n\n다시 수행하면 예상과 달리 또 통과가 되는데요.  \n이유는 validation 어노테이션을 체크할수 있는 장치가 추가로 필요하기 때문입니다.\n\n```java\npublic class ValidationApplication {\n    \n    // ...\n    @GetMapping(\"/hello\")\n    public String helloName(@Valid HelloRequest helloRequest) { // (1)\n\n        return helloRequest.getMessage();\n    }\n    // ...\n}\n```\n\n(1) @Valid 어노테이션을 추가하였습니다.\n\n다시 수행하면 예상처럼 테스트가 실패가 됩니다.  \n테스트를 성공시키도록 수정해보겠습니다.\n\n```java\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.MvcResult;\nimport org.springframework.test.web.servlet.ResultActions;\nimport org.springframework.validation.BindException;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.tuple;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@WebMvcTest\nclass HelloControllerTest {\n\n    // ...\n    \n    @Test\n    @DisplayName(\"hello 컨트롤러에 파라미터를 전달 안하면 name validation 이 작동한다\") // (1)\n    void helloTest1() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n        );\n\n        // then\n        MvcResult mvcResult = resultActions\n                .andExpect(status().isBadRequest())\n                .andReturn();\n\n        assertThat(((BindException) mvcResult.getResolvedException()).getBindingResult().getFieldErrors()) // (2)\n                .extracting(\"field\", \"defaultMessage\")\n                .containsExactlyInAnyOrder(\n                        tuple(\"name\", \"이름은 빈값일 수 없습니다.\")\n                );\n    }\n}\n```\n\n(1) 테스트 이름을 변경합니다.  \n(2) 바인딩 에러를 잡아서 검증합니다.\n\n이제 통과를 할것입니다.  \n우리가 원하던대로 null 을 막았습니다.\n\nname 에 빈값이 들어가면 어떻게 될까요?  \n저는 빈값도 예외가 나오길 원합니다.\n\n테스트를 추가해보겠습니다.\n\n```java\n\n@WebMvcTest\nclass HelloControllerTest {\n    \n    // ...\n    \n    @Test\n    @DisplayName(\"hello 컨트롤러에 name 값을 빈값으로 전달하면 name validation 이 작동한다\")\n    void helloTest2() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n                .param(\"name\", \"\") // (1)\n        );\n\n        // then\n        MvcResult mvcResult = resultActions\n                .andExpect(status().isBadRequest())\n                .andReturn();\n\n        assertThat(((BindException) mvcResult.getResolvedException()).getBindingResult().getFieldErrors())\n                .extracting(\"field\", \"defaultMessage\")\n                .containsExactlyInAnyOrder(\n                        tuple(\"name\", \"이름은 빈값일 수 없습니다.\")\n                );\n    }\n}\n```\n\n(1) 먼저 작성한 테스트와 동일하지만 파라미터로 name 이 추가되었습니다.\n\n다시 수행하면 예상과 다르게 status 가 isOk 가 되면서 테스트가 실패하게 됩니다. 우리는 @NotNull 을 넣었는데 왜 통과가 되는것일까요?\n\nNotNull 의 javaDoc 을 보면\n\n\u003e The annotated element must not be null. Accepts any type.\n\n이렇게 되어있습니다.  \nnull 만 체크하는용도입니다.\n\n## NotBlank\n\n코드를 수정해보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotBlank(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private String name;\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n```\n\n(1) @NotBlank 로 변경해보겠습니다.\n\n테스트를 재수행해보면 통과하는것을 알 수 있습니다.\n\nNotBlank 의 javaDoc 을 보면\n\n\u003e The annotated element must not be null and must contain at least one non-whitespace character.  \n\u003e Accepts CharSequence.\n\n이렇게 되어있습니다.  \nNotBlank 는 null 과 빈문자열을 체크하네요.\n\n## NotEmpty\n\n그동안 api 는 안녕 철수. 안녕 영희 같이 한명을 대상으로 했습니다.\n\n근데 저는 안녕 철수, 영희 처럼 2명을 대상으로 하고 싶어졌습니다.\n\n아래처럼 변경해보죠.\n\n```java\npublic static class HelloRequest {\n\n    @NotBlank(message = \"이름은 빈값일 수 없습니다.\")\n    private List\u003cString\u003e name; // (1)\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n```\n\n리스트로 변경해봅니다.  \n테스트를 재수행하면 아래와 같은 오류를 내뿜으면서 다 깨집니다.\n\n```\nNo validator could be found for constraint 'javax.validation.constraints.NotBlank' validating type 'java.util.List\u003cjava.lang.String\u003e'. Check configuration for 'name'\n```\n\nNotBlank 를 List 에 쓸수 없다 라고 나오네요.\n\n다시 코드를 변경해보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotNull(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private List\u003cString\u003e name;\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n```\n\n(1) NotNull 로 다시 변경했습니다.\n\n테스트를 재수행하니 helloTest1은 통과되고 helloTest2는 isOk를 내보내면서 실패했네요.\n\n@NotNull 로는 빈배열을 체크할수 없습니다.\n\n코드를 수정해보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotEmpty(message = \"이름은 빈값일 수 없습니다.\") // (1) \n    private List\u003cString\u003e name;\n\n    public String getMessage() {\n        return String.format(\"hello %s\", name);\n    }\n}\n```\n\n(1) NotEmpty 로 변경했습니다.\n\n테스트를 재수행하니 통과되었습니다.\n\nNotEmpty 의 javaDoc 을 보면\n\n\u003e The annotated element must not be null nor empty.  \n\u003e Supported types are:    \n\u003e CharSequence (length of character sequence is evaluated)  \n\u003e Collection (collection size is evaluated)  \n\u003e Map (map size is evaluated)  \n\u003e Array (array length is evaluated)\n\n이렇게 되어있습니다.    \nNotEmpty 는 null 과 비어있는지 체크를 합니다.\n\n## 결론\n\n검증하려는 필드가 List 인가?\n\nyes → @NotEmpty\n\nno → 아래문항으로\n\n검증하려는 필드가 String 인가?\n\nyes → @NotBlank\n\nno → @NotNull\n\n읽어주셔서 감사합니다."},{"id":"1","title":"첫 블로그","description":"2021년 블로그를 시작과 인사말","date":"2021. 01. 01.","category":["기타"],"content":"\n2021년을 맞이하여 블로그를 꾸준히 운영을 해보려합니다.\n\n제가 필요한 기술들과   \n회사에서 접했던 문제들을 공유하려 합니다.\n\n일단 블로그는 next 로 틀만 만들고 차츰차츰 꾸밀거에요.\n\n블로그를 꾸미는 과정도 시리즈로 제공을 해볼게요.\n\n방문해주셔서 감사합니다."}],"categories":[{"id":"기타","count":1},{"id":"Bean Validation","count":1},{"id":"Spring","count":1},{"id":"Java","count":1}]},"__N_SSG":true},"page":"/[id]","query":{"id":"2"},"buildId":"k54kP0spbugFTihzugjo0","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-250f16924c392849df26.js"></script><script src="/_next/static/chunks/main-99ad68a3f1273cf1678f.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.a6402fb70cc88f6f61b0.js" async=""></script><script src="/_next/static/chunks/commons.7af247b43e14ac66e88e.js" async=""></script><script src="/_next/static/chunks/f658db493258337e4ee0c0d6b56e2d9169f0c93b.88d5ad5fd990ced1c5da.js" async=""></script><script src="/_next/static/chunks/pages/_app-ea914611bb791faec916.js" async=""></script><script src="/_next/static/chunks/pages/%5Bid%5D-ee51f05b8ea1a0f56175.js" async=""></script><script src="/_next/static/k54kP0spbugFTihzugjo0/_buildManifest.js" async=""></script><script src="/_next/static/k54kP0spbugFTihzugjo0/_ssgManifest.js" async=""></script></body></html>