{"pageProps":{"post":{"id":"1","title":"첫 블로그","description":"2021년 블로그를 시작과 인사말","date":"2021. 01. 01.","category":["기타"],"content":"<p>2021년을 맞이하여 블로그를 꾸준히 운영을 해보려합니다.</p>\n<p>제가 필요한 기술들과<br>\n회사에서 접했던 문제들을 공유하려 합니다.</p>\n<p>일단 블로그는 next 로 틀만 만들고 차츰차츰 꾸밀거에요.</p>\n<p>블로그를 꾸미는 과정도 시리즈로 제공을 해볼게요.</p>\n<p>방문해주셔서 감사합니다.</p>\n"},"recentPosts":[{"id":"2","title":"@NotNull vs @NotEmpty vs @NotBlank","description":"@NotNull, @NotEmpty, @NotBlank 를 언제 사용해야하는지 설명합니다.","date":"2021. 01. 11.","category":["Bean Validation","Spring","Java"],"content":"\n## 시작하면서\n\nspring 을 하면서 validation 에 대해 얘기해보려합니다.\n\n웹 서비스를 만들면서 다양하게 검증을 사용할 일이 생깁니다.\n\n웹프로그램을 만들다보면 프리젠테이션 계층부터 지속성 계층까지 반복적인 유효성검사는 코드의 품질을 떨어뜨리고 오류발생을 높입니다.\n그래서  [JSR-303](https://jcp.org/en/jsr/detail?id=303) 이 나왔습니다.\n\n그리고 자바 8이 나오고나서 자바8에 맞추어 bean validation 2.0 에 맞게 [JSR-380](https://jcp.org/en/jsr/detail?id=380) 이 나왔습니다.\n\n> JSR 은 자바스펙요구서 (Java Specification Request)\n\n이런 Bean Validation 을 사용하면 쉽게 검증을 적용할수 있습니다.\n\n하지만 그동안 코드리뷰를 하면서 NotNull, NotEmpty 그리고 NotBlank 를 혼용하는 분들을 종종 발견하곤 합니다.\n\n그래서 해당 내용을 정리하려합니다.\n\n## @NotNull\n\n```java\npackage com.example.code.validation;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.InitBinder;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@SpringBootApplication\npublic class ValidationApplication {\n\n    @InitBinder\n    public void initBinder(WebDataBinder binder) {\n        binder.initDirectFieldAccess();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(ValidationApplication.class, args);\n    }\n\n    @GetMapping(\"/hello\")\n    public String helloName(HelloRequest helloRequest) {\n\n        return helloRequest.getMessage();\n    }\n\n    public static class HelloRequest {\n\n       private String name;\n\n        public String getMessage() {\n            return String.format(\"안녕 %s\", name);\n        }\n    }\n}\n```\n\n/hello 을 호출하게 되면 \"안녕 이름\" 이 호출되는 간단한 컨트롤러입니다.\n> request 에 setter 를 안넣는 방법은 조졸두님 [블로그](https://jojoldu.tistory.com/407) 를 참고해주세요.\n\n```java\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.ResultActions;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@WebMvcTest\nclass HelloControllerTest {\n\n    @Autowired\n    MockMvc mvc;\n\n    @Test\n    @DisplayName(\"hello 컨트롤러가 잘 되는지 확인\")\n    void helloTest1() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n        );\n\n        // then\n        resultActions\n                .andExpect(status().isOk())\n                .andExpect(content().string(\"안녕 null\"));\n\n    }\n}\n```\n\n테스트 코드입니다.  \n테스트는 통과과 되겠지만 결과 데이터는 안녕 null 입니다.  \nname 이 null 이 되면 안될것 같습니다.\n\n코드를 고쳐보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotNull(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private String name;\n\n    public String getMessage() {\n        return String.format(\"hello %s\", name);\n    }\n}\n```\n\n(1) HelloRequest 에 @NotNull 을 추가합니다.\n\n다시 수행하면 예상과 달리 또 통과가 되는데요.  \n이유는 validation 어노테이션을 체크할수 있는 장치가 추가로 필요하기 때문입니다.\n\n```java\npublic class ValidationApplication {\n    \n    // ...\n    @GetMapping(\"/hello\")\n    public String helloName(@Valid HelloRequest helloRequest) { // (1)\n\n        return helloRequest.getMessage();\n    }\n    // ...\n}\n```\n\n(1) @Valid 어노테이션을 추가하였습니다.\n\n다시 수행하면 예상처럼 테스트가 실패가 됩니다.  \n테스트를 성공시키도록 수정해보겠습니다.\n\n```java\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.MvcResult;\nimport org.springframework.test.web.servlet.ResultActions;\nimport org.springframework.validation.BindException;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.tuple;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@WebMvcTest\nclass HelloControllerTest {\n\n    // ...\n    \n    @Test\n    @DisplayName(\"hello 컨트롤러에 파라미터를 전달 안하면 name validation 이 작동한다\") // (1)\n    void helloTest1() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n        );\n\n        // then\n        MvcResult mvcResult = resultActions\n                .andExpect(status().isBadRequest())\n                .andReturn();\n\n        assertThat(((BindException) mvcResult.getResolvedException()).getBindingResult().getFieldErrors()) // (2)\n                .extracting(\"field\", \"defaultMessage\")\n                .containsExactlyInAnyOrder(\n                        tuple(\"name\", \"이름은 빈값일 수 없습니다.\")\n                );\n    }\n}\n```\n\n(1) 테스트 이름을 변경합니다.  \n(2) 바인딩 에러를 잡아서 검증합니다.\n\n이제 통과를 할것입니다.  \n우리가 원하던대로 null 을 막았습니다.\n\nname 에 빈값이 들어가면 어떻게 될까요?  \n저는 빈값도 예외가 나오길 원합니다.\n\n테스트를 추가해보겠습니다.\n\n```java\n\n@WebMvcTest\nclass HelloControllerTest {\n    \n    // ...\n    \n    @Test\n    @DisplayName(\"hello 컨트롤러에 name 값을 빈값으로 전달하면 name validation 이 작동한다\")\n    void helloTest2() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n                .param(\"name\", \"\") // (1)\n        );\n\n        // then\n        MvcResult mvcResult = resultActions\n                .andExpect(status().isBadRequest())\n                .andReturn();\n\n        assertThat(((BindException) mvcResult.getResolvedException()).getBindingResult().getFieldErrors())\n                .extracting(\"field\", \"defaultMessage\")\n                .containsExactlyInAnyOrder(\n                        tuple(\"name\", \"이름은 빈값일 수 없습니다.\")\n                );\n    }\n}\n```\n\n(1) 먼저 작성한 테스트와 동일하지만 파라미터로 name 이 추가되었습니다.\n\n다시 수행하면 예상과 다르게 status 가 isOk 가 되면서 테스트가 실패하게 됩니다. 우리는 @NotNull 을 넣었는데 왜 통과가 되는것일까요?\n\nNotNull 의 javaDoc 을 보면\n\n> The annotated element must not be null. Accepts any type.\n\n이렇게 되어있습니다.  \nnull 만 체크하는용도입니다.\n\n## NotBlank\n\n코드를 수정해보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotBlank(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private String name;\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n```\n\n(1) @NotBlank 로 변경해보겠습니다.\n\n테스트를 재수행해보면 통과하는것을 알 수 있습니다.\n\nNotBlank 의 javaDoc 을 보면\n\n> The annotated element must not be null and must contain at least one non-whitespace character.  \n> Accepts CharSequence.\n\n이렇게 되어있습니다.  \nNotBlank 는 null 과 빈문자열을 체크하네요.\n\n## NotEmpty\n\n그동안 api 는 안녕 철수. 안녕 영희 같이 한명을 대상으로 했습니다.\n\n근데 저는 안녕 철수, 영희 처럼 2명을 대상으로 하고 싶어졌습니다.\n\n아래처럼 변경해보죠.\n\n```java\npublic static class HelloRequest {\n\n    @NotBlank(message = \"이름은 빈값일 수 없습니다.\")\n    private List<String> name; // (1)\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n```\n\n리스트로 변경해봅니다.  \n테스트를 재수행하면 아래와 같은 오류를 내뿜으면서 다 깨집니다.\n\n```\nNo validator could be found for constraint 'javax.validation.constraints.NotBlank' validating type 'java.util.List<java.lang.String>'. Check configuration for 'name'\n```\n\nNotBlank 를 List 에 쓸수 없다 라고 나오네요.\n\n다시 코드를 변경해보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotNull(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private List<String> name;\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n```\n\n(1) NotNull 로 다시 변경했습니다.\n\n테스트를 재수행하니 helloTest1은 통과되고 helloTest2는 isOk를 내보내면서 실패했네요.\n\n@NotNull 로는 빈배열을 체크할수 없습니다.\n\n코드를 수정해보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotEmpty(message = \"이름은 빈값일 수 없습니다.\") // (1) \n    private List<String> name;\n\n    public String getMessage() {\n        return String.format(\"hello %s\", name);\n    }\n}\n```\n\n(1) NotEmpty 로 변경했습니다.\n\n테스트를 재수행하니 통과되었습니다.\n\nNotEmpty 의 javaDoc 을 보면\n\n> The annotated element must not be null nor empty.  \n> Supported types are:    \n> CharSequence (length of character sequence is evaluated)  \n> Collection (collection size is evaluated)  \n> Map (map size is evaluated)  \n> Array (array length is evaluated)\n\n이렇게 되어있습니다.    \nNotEmpty 는 null 과 비어있는지 체크를 합니다.\n\n## 결론\n\n검증하려는 필드가 List 인가?\n\nyes → @NotEmpty\n\nno → 아래문항으로\n\n검증하려는 필드가 String 인가?\n\nyes → @NotBlank\n\nno → @NotNull\n\n읽어주셔서 감사합니다."},{"id":"1","title":"첫 블로그","description":"2021년 블로그를 시작과 인사말","date":"2021. 01. 01.","category":["기타"],"content":"\n2021년을 맞이하여 블로그를 꾸준히 운영을 해보려합니다.\n\n제가 필요한 기술들과   \n회사에서 접했던 문제들을 공유하려 합니다.\n\n일단 블로그는 next 로 틀만 만들고 차츰차츰 꾸밀거에요.\n\n블로그를 꾸미는 과정도 시리즈로 제공을 해볼게요.\n\n방문해주셔서 감사합니다."}],"categories":[{"id":"기타","count":1},{"id":"Bean Validation","count":1},{"id":"Spring","count":1},{"id":"Java","count":1}]},"__N_SSG":true}