{"pageProps":{"category":"Spring","allPostsData":[{"id":"2","title":"@NotNull vs @NotEmpty vs @NotBlank","description":"@NotNull, @NotEmpty, @NotBlank 를 언제 사용해야하는지 설명합니다.","date":"2021. 01. 11.","category":["Bean Validation","Spring","Java"],"content":"\n## 시작하면서\n\nspring 을 하면서 validation 에 대해 얘기해보려합니다.\n\n웹 서비스를 만들면서 다양하게 검증을 사용할 일이 생깁니다.\n\n웹프로그램을 만들다보면 프리젠테이션 계층부터 지속성 계층까지 반복적인 유효성검사는 코드의 품질을 떨어뜨리고 오류발생을 높입니다.\n그래서  [JSR-303](https://jcp.org/en/jsr/detail?id=303) 이 나왔습니다.\n\n그리고 자바 8이 나오고나서 자바8에 맞추어 bean validation 2.0 에 맞게 [JSR-380](https://jcp.org/en/jsr/detail?id=380) 이 나왔습니다.\n\n> JSR 은 자바스펙요구서 (Java Specification Request)\n\n이런 Bean Validation 을 사용하면 쉽게 검증을 적용할수 있습니다.\n\n하지만 그동안 코드리뷰를 하면서 NotNull, NotEmpty 그리고 NotBlank 를 혼용하는 분들을 종종 발견하곤 합니다.\n\n그래서 해당 내용을 정리하려합니다.\n\n## @NotNull\n\n```java\npackage com.example.code.validation;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.InitBinder;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@SpringBootApplication\npublic class ValidationApplication {\n\n    @InitBinder\n    public void initBinder(WebDataBinder binder) {\n        binder.initDirectFieldAccess();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(ValidationApplication.class, args);\n    }\n\n    @GetMapping(\"/hello\")\n    public String helloName(HelloRequest helloRequest) {\n\n        return helloRequest.getMessage();\n    }\n\n    public static class HelloRequest {\n\n       private String name;\n\n        public String getMessage() {\n            return String.format(\"안녕 %s\", name);\n        }\n    }\n}\n```\n\n/hello 을 호출하게 되면 \"안녕 이름\" 이 호출되는 간단한 컨트롤러입니다.\n> request 에 setter 를 안넣는 방법은 조졸두님 [블로그](https://jojoldu.tistory.com/407) 를 참고해주세요.\n\n```java\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.ResultActions;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@WebMvcTest\nclass HelloControllerTest {\n\n    @Autowired\n    MockMvc mvc;\n\n    @Test\n    @DisplayName(\"hello 컨트롤러가 잘 되는지 확인\")\n    void helloTest1() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n        );\n\n        // then\n        resultActions\n                .andExpect(status().isOk())\n                .andExpect(content().string(\"안녕 null\"));\n\n    }\n}\n```\n\n테스트 코드입니다.  \n테스트는 통과과 되겠지만 결과 데이터는 안녕 null 입니다.  \nname 이 null 이 되면 안될것 같습니다.\n\n코드를 고쳐보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotNull(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private String name;\n\n    public String getMessage() {\n        return String.format(\"hello %s\", name);\n    }\n}\n```\n\n(1) HelloRequest 에 @NotNull 을 추가합니다.\n\n다시 수행하면 예상과 달리 또 통과가 되는데요.  \n이유는 validation 어노테이션을 체크할수 있는 장치가 추가로 필요하기 때문입니다.\n\n```java\npublic class ValidationApplication {\n    \n    // ...\n    @GetMapping(\"/hello\")\n    public String helloName(@Valid HelloRequest helloRequest) { // (1)\n\n        return helloRequest.getMessage();\n    }\n    // ...\n}\n```\n\n(1) @Valid 어노테이션을 추가하였습니다.\n\n다시 수행하면 예상처럼 테스트가 실패가 됩니다.  \n테스트를 성공시키도록 수정해보겠습니다.\n\n```java\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.MvcResult;\nimport org.springframework.test.web.servlet.ResultActions;\nimport org.springframework.validation.BindException;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.tuple;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@WebMvcTest\nclass HelloControllerTest {\n\n    // ...\n    \n    @Test\n    @DisplayName(\"hello 컨트롤러에 파라미터를 전달 안하면 name validation 이 작동한다\") // (1)\n    void helloTest1() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n        );\n\n        // then\n        MvcResult mvcResult = resultActions\n                .andExpect(status().isBadRequest())\n                .andReturn();\n\n        assertThat(((BindException) mvcResult.getResolvedException()).getBindingResult().getFieldErrors()) // (2)\n                .extracting(\"field\", \"defaultMessage\")\n                .containsExactlyInAnyOrder(\n                        tuple(\"name\", \"이름은 빈값일 수 없습니다.\")\n                );\n    }\n}\n```\n\n(1) 테스트 이름을 변경합니다.  \n(2) 바인딩 에러를 잡아서 검증합니다.\n\n이제 통과를 할것입니다.  \n우리가 원하던대로 null 을 막았습니다.\n\nname 에 빈값이 들어가면 어떻게 될까요?  \n저는 빈값도 예외가 나오길 원합니다.\n\n테스트를 추가해보겠습니다.\n\n```java\n\n@WebMvcTest\nclass HelloControllerTest {\n    \n    // ...\n    \n    @Test\n    @DisplayName(\"hello 컨트롤러에 name 값을 빈값으로 전달하면 name validation 이 작동한다\")\n    void helloTest2() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n                .param(\"name\", \"\") // (1)\n        );\n\n        // then\n        MvcResult mvcResult = resultActions\n                .andExpect(status().isBadRequest())\n                .andReturn();\n\n        assertThat(((BindException) mvcResult.getResolvedException()).getBindingResult().getFieldErrors())\n                .extracting(\"field\", \"defaultMessage\")\n                .containsExactlyInAnyOrder(\n                        tuple(\"name\", \"이름은 빈값일 수 없습니다.\")\n                );\n    }\n}\n```\n\n(1) 먼저 작성한 테스트와 동일하지만 파라미터로 name 이 추가되었습니다.\n\n다시 수행하면 예상과 다르게 status 가 isOk 가 되면서 테스트가 실패하게 됩니다. 우리는 @NotNull 을 넣었는데 왜 통과가 되는것일까요?\n\nNotNull 의 javaDoc 을 보면\n\n> The annotated element must not be null. Accepts any type.\n\n이렇게 되어있습니다.  \nnull 만 체크하는용도입니다.\n\n## NotBlank\n\n코드를 수정해보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotBlank(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private String name;\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n```\n\n(1) @NotBlank 로 변경해보겠습니다.\n\n테스트를 재수행해보면 통과하는것을 알 수 있습니다.\n\nNotBlank 의 javaDoc 을 보면\n\n> The annotated element must not be null and must contain at least one non-whitespace character.  \n> Accepts CharSequence.\n\n이렇게 되어있습니다.  \nNotBlank 는 null 과 빈문자열을 체크하네요.\n\n## NotEmpty\n\n그동안 api 는 안녕 철수. 안녕 영희 같이 한명을 대상으로 했습니다.\n\n근데 저는 안녕 철수, 영희 처럼 2명을 대상으로 하고 싶어졌습니다.\n\n아래처럼 변경해보죠.\n\n```java\npublic static class HelloRequest {\n\n    @NotBlank(message = \"이름은 빈값일 수 없습니다.\")\n    private List<String> name; // (1)\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n```\n\n리스트로 변경해봅니다.  \n테스트를 재수행하면 아래와 같은 오류를 내뿜으면서 다 깨집니다.\n\n```\nNo validator could be found for constraint 'javax.validation.constraints.NotBlank' validating type 'java.util.List<java.lang.String>'. Check configuration for 'name'\n```\n\nNotBlank 를 List 에 쓸수 없다 라고 나오네요.\n\n다시 코드를 변경해보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotNull(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private List<String> name;\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n```\n\n(1) NotNull 로 다시 변경했습니다.\n\n테스트를 재수행하니 helloTest1은 통과되고 helloTest2는 isOk를 내보내면서 실패했네요.\n\n@NotNull 로는 빈배열을 체크할수 없습니다.\n\n코드를 수정해보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotEmpty(message = \"이름은 빈값일 수 없습니다.\") // (1) \n    private List<String> name;\n\n    public String getMessage() {\n        return String.format(\"hello %s\", name);\n    }\n}\n```\n\n(1) NotEmpty 로 변경했습니다.\n\n테스트를 재수행하니 통과되었습니다.\n\nNotEmpty 의 javaDoc 을 보면\n\n> The annotated element must not be null nor empty.  \n> Supported types are:    \n> CharSequence (length of character sequence is evaluated)  \n> Collection (collection size is evaluated)  \n> Map (map size is evaluated)  \n> Array (array length is evaluated)\n\n이렇게 되어있습니다.    \nNotEmpty 는 null 과 비어있는지 체크를 합니다.\n\n## 결론\n\n검증하려는 필드가 List 인가?\n\nyes → @NotEmpty\n\nno → 아래문항으로\n\n검증하려는 필드가 String 인가?\n\nyes → @NotBlank\n\nno → @NotNull\n\n읽어주셔서 감사합니다."}],"recentPosts":[{"id":"3","title":"클래스 만들때 빌더 vs 정적 팩토리 메서드","description":"클래스를 만들떄 빌더와 정적 팩토리 메서드 어떤걸 사용하시나요? 제 생각을 얘기해보겠습니다.","date":"2021. 01. 18.","category":["Java","Lombok"],"content":"\n## 시작하면서\n\n몇일전 아는 동생에게서 아래와 같은 질문이 들어왔습니다.\n\n![img](../public/assets/3/img_1.jpg)\n그래서 동생한테 제 기준을 설명했는데 이 설명한 내용을 블로그에 써보도록 하겠습니다.\n\n일반적으로 클래스를 이용해서 객체를 만들때는 생성자를 사용합니다.\n\n그 외에 방법으로 자주 쓰이는 빌더와 정적팩토리메서드를 저는 언제 사용하는지 설명드리도록 하겠습니다.\n\n## 빌더\n\n> effective java 규칙2  \n> 생성자 인자가 많을때는 Builder 패턴 적용을 고려하라\n\n저는 정산시스템을 개발하다보니 금액을 나타내는 필드를 여러개 사용하고 있습니다.  \n그러다보니 하나의 클래스에 여러개의 금액필드를 생성자로 넣게 되는 경우가 많아집니다.  \n아래와 같이 말이죠.\n\n```java\n\npublic class Settle {\n    ...\n    public Settle(long a, long b, long c, long d, ...) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    ...\n    }\n}\n\nnew Settle(100_000L, 10_000L, 200_000L, 100_000L, ...);\n```\n\n여기에는 몇개의 문제가 있습니다.\n\n1. new Settle 을 호출한 부분에서 필드들의 타입이 같으니 어떤 필드가 뭘 의미하는지 쉽게 알수 없습니다.\n2. 불필요한 필드가 있을시 null 을 넣거나 새로 생성자를 만들어야합니다.\n3. 필드가 추가 된다면 생성자를 호출하는 모든 클래스를 수정하거나 필드가 변경된 생성자를 하나 더 만들어야합니다.\n\n이러한 문제들을 빌더를 사용하면 싹 해결이 됩니다.\n\n저는 몇년전까지만 해도 빌더를 사용하지 않았습니다.  \n이유는 빌더객체를 만드는데 오버헤드가 컸고 그동안 만들었던 것들은 필드가 그렇게 많지 않았기때문이였습니다.\n\n지금은 필드가 많던 적던 빌더를 자주 사용하는 편입니다.  \n이유는 Lombok 을 사용하면 빌더를 편하게 만들수 있기 때문입니다.\n\n```java\n\npublic class Settle {\n    ...\n    @Builder\n    private Settle(long a, long b, long c, long d, ...) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    ...\n    }\n}\n\nSettle.builder()\n    .a(100_000L)\n    .b(10_000L)\n    .build();\n\n\nSettle.builder()\n    .a(100_000L)\n    .b(10_000L)\n    .c(200_000L) \n    .build();\n```\n\n저를 비롯한 팀에서는 클래스에 빌더를 선언하지 않고 생성자에 선언합니다.  \n이유로는 저희는 테스트에서 사용하는 테스트 빌더  \n그리고 프로덕트에서 사용하는 빌더 2종류를 만들어서 사용하기 때문입니다.\n\n> 클래스에 빌더를 작성하면 암묵적으로 @AllArgsConstructor private 로 생성\n\n```java\n\npublic class Settle {\n    ...\n    @Builder\n    private Settle(long a, long b, long c) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n    \n    @Builder(builderClassName=\"TestBuilder\", builderMethodName=\"testBuilder\")\n    private Settle(long a, long b, long c, long d, ...) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    ...\n    }\n}\n\nSettle.builder()\n    .a(100_000L)\n    .b(10_000L)\n    .build();\n\n\nSettle.testBuilder()\n    .a(100_000L)\n    .b(10_000L)\n    .c(200_000L)\n    .d(100_000L)\n    .build();\n```\n\n테스트빌더와 프로덕트빌더를 따로 만든 이유는 빌더라고 해서 모든 필드에 열려있으면  \n실제 프로덕트에서 하는 일들이 뭔지 알기 쉽지가 않습니다.  \n그래서 최소한의 필드로 열어두고 필요할때마다 필드를 추가하는 방식을 사용합니다.\n\n## 정적 팩토리 메서드\n\n> effective java 규칙1  \n> 생성자 대신 정적 팩토리 메서드를 사용할 수 없는지 생각해 보라.\n\n생성자로만 그리고 빌더로만 사용하기에는 아쉬울때가 있습니다.  \n저는 외부에서 호출하는것들에는 최소한의 인자만 사용하는게 좋다고 생각합니다.\n\n예를 들면 아래와 같은 클래스가 있다고 합시다.\n\n```java\npublic class Order {\n    private OrderStatus status;\n    private LocalDate orderDate;\n    private String orderNo;\n    private long price;\n            \n    // 생성자 생략\n    // 빌더 생략\n    enum OrderStatus {\n        PAY,\n        DELIVERY,\n        DONE,\n        CANCEL,\n        RETURN\n    }\n}\n```\n\n외부에서 아래와 같이 사용할수 있습니다.\n\n```java\nnew Order(PAY, LocalDate.of(2021, 1, 18), \"20210118001\", 100_000L);\n\nnew Order(CANCEL, LocalDate.of(2021, 1, 18), \"20210118001\", 100_000L);\n\n// 혹은\nOrder.builder()\n    .status(PAY)\n    .orderDate(LocalDate.of(2021, 1, 18))\n    .orderNo(\"20210118001\")\n    .price(100_000L)\n    .build();\n\nOrder.builder()\n    .status(CANCEL)\n    .orderDate(LocalDate.of(2021, 1, 18))\n    .orderNo(\"20210118001\")\n    .price(100_000L)\n    .build();\n```\n\n생성자든 빌더든 정확한 의도를 알기가 쉽지 않습니다.  \n물론 빌더의 이름을 넣을순 있겠지만 매번 비슷한 필드로 생성자를 만들려면  \n인자 순서를 변경하는 꼼수를 부릴수 밖에 없습니다.  \n그리고 클래스 내부에 있는 enum 을 호출하는곳에서 사용하려면 Order.OrderStatus.PAY 같이 작성해야합니다.\n\n이때 정적팩토리 메서드를 사용해주면 아래와 같이 변경할 수 있습니다.\n\n```java\n\npublic class Order {\n    private OrderStatus status;\n    private LocalDate orderDate;\n    private String orderNo;\n    private long price;\n\n    // 빌더 여기 예제에서는 빌더 accessLevel 도 PRIVATE 하게 가능\n    \n    \n    public static payOf(LocalDate orderDate, String orderNo, long price) {\n        return Order.builder()\n                .status(PAY)\n                .orderDate(orderDate)\n                .orderNo(orderNo)\n                .price(price)\n                .build();\n    }\n    \n    public static cancelOf(Order order, LocalDate cancelDate) {\n        return Order.builder()\n                .status(CANCEL)\n                .orderDate(cancelDate)\n                .orderNo(order.orderNo)\n                .price(order.price)\n                .build();\n    }\n    \n    enum OrderStatus {\n        PAY,\n        DELIVERY,\n        DONE,\n        CANCEL,\n        RETURN\n    }\n}\n```\n\n외부에서 아래와 같이 사용할수 있습니다.\n\n```java\nOrder.payOf(LocalDate.of(2021, 1, 18), \"20210118001\", 100_000L);\n\nOrder.cancelOf(order, LocalDate.of(2021, 1, 18));\n```\n\n조금 더 이름으로 확연히 구분이 되고 enum 과 builder를 외부에 노출을 안시킬 수 있습니다.\n\n또한 변경불가능한 객체를 재사용하는 용도로 사용가능합니다.  \n예를 들면 외부에 빈컬렉션을 제공할시\n\n```java\nreturn new ArrayList<>();\n\nreturn Collections.emptyList();\n```\n\n위에 대신 밑에를 사용함으로써 객체를 새로 생성 안하고 재사용이 가능합니다.  \n이걸 이용해서 다른 객체들도 재사용가능하게 만들수 있습니다. (중요한건 불변객체여야합니다.)\n\n## 둘중에 뭘 써야하나?\n\n전 둘다 사용하고 있습니다.\n\n```java\n@Entity // 도메인 계층, 상위 계층\npublic class Settle {\n    ...\n}\n\n// 하위 계층\npublic class SettleDto {\n    private OrderStatus status;\n    private LocalDate orderDate;\n    private String orderNo;\n    private long price;\n\n    // 빌더\n    \n    // entity -> dto (1)\n    public static SettleDto from(Settle order) {\n        return SettleDto.builder()\n                .a(order.getA())\n                .b(order.getB())\n                .c(order.getC())\n                .d(order.getD())\n                .build();\n    }\n \n    // dto -> entity (2)\n    public Settle toEntity() {\n        return Settle.build()\n                .a(a)\n                .b(b)\n                .c(c)\n                .d(d)\n                .build();\n    }\n}\n\n```\n\n하위(dto) 계층에서는 상위(entity) 계층을 알 수 있으니 (1) 처럼 팩토리메서드를 사용하고  \n상위(entity) 계층에서는 하위(dto) 계층을 알 수 없으니 (2) 처럼 하위 계층에서 빌더로 구현합니다.  \n(2) 같은 경우에는 별도의 팩토리클래스를 만들어서 사용하시는 분들도 계신데  \n저는 일단 DTO에서 해당 역할을 하게 했습니다.  \n팩토리 클래스에서도 빌더를 사용하는것은 똑같을것 같습니다.\n\n그리고 그 외에 인자가 4개가 넘어가면 클래스로 넘겨서 사용할수 있는지 먼저 체크를 하고  \n딱히 묶을수 있는 클래스가 없다고 한다면 빌더를 사용했습니다.\n\n## 결론\n\n불변성을 띄며 캐시를 해도 되는가?   \nyes -> 정적 팩토리 메서드  \nno -> 아래 문항으로\n\n불필요한 클래스 생성이나 계층의 역전없이 인자를 3개 이하로 줄일수 있는가?  \nyes -> 정적 팩토리 메서드  \nno -> 빌더\n\n설명한걸 결론짓기가 매우 난해하네요.  \n다른 분들은 어떻게 하고 계신지 궁금합니다.\n"},{"id":"2","title":"@NotNull vs @NotEmpty vs @NotBlank","description":"@NotNull, @NotEmpty, @NotBlank 를 언제 사용해야하는지 설명합니다.","date":"2021. 01. 11.","category":["Bean Validation","Spring","Java"],"content":"\n## 시작하면서\n\nspring 을 하면서 validation 에 대해 얘기해보려합니다.\n\n웹 서비스를 만들면서 다양하게 검증을 사용할 일이 생깁니다.\n\n웹프로그램을 만들다보면 프리젠테이션 계층부터 지속성 계층까지 반복적인 유효성검사는 코드의 품질을 떨어뜨리고 오류발생을 높입니다.\n그래서  [JSR-303](https://jcp.org/en/jsr/detail?id=303) 이 나왔습니다.\n\n그리고 자바 8이 나오고나서 자바8에 맞추어 bean validation 2.0 에 맞게 [JSR-380](https://jcp.org/en/jsr/detail?id=380) 이 나왔습니다.\n\n> JSR 은 자바스펙요구서 (Java Specification Request)\n\n이런 Bean Validation 을 사용하면 쉽게 검증을 적용할수 있습니다.\n\n하지만 그동안 코드리뷰를 하면서 NotNull, NotEmpty 그리고 NotBlank 를 혼용하는 분들을 종종 발견하곤 합니다.\n\n그래서 해당 내용을 정리하려합니다.\n\n## @NotNull\n\n```java\npackage com.example.code.validation;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.InitBinder;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@SpringBootApplication\npublic class ValidationApplication {\n\n    @InitBinder\n    public void initBinder(WebDataBinder binder) {\n        binder.initDirectFieldAccess();\n    }\n\n    public static void main(String[] args) {\n        SpringApplication.run(ValidationApplication.class, args);\n    }\n\n    @GetMapping(\"/hello\")\n    public String helloName(HelloRequest helloRequest) {\n\n        return helloRequest.getMessage();\n    }\n\n    public static class HelloRequest {\n\n       private String name;\n\n        public String getMessage() {\n            return String.format(\"안녕 %s\", name);\n        }\n    }\n}\n```\n\n/hello 을 호출하게 되면 \"안녕 이름\" 이 호출되는 간단한 컨트롤러입니다.\n> request 에 setter 를 안넣는 방법은 조졸두님 [블로그](https://jojoldu.tistory.com/407) 를 참고해주세요.\n\n```java\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.ResultActions;\n\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@WebMvcTest\nclass HelloControllerTest {\n\n    @Autowired\n    MockMvc mvc;\n\n    @Test\n    @DisplayName(\"hello 컨트롤러가 잘 되는지 확인\")\n    void helloTest1() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n        );\n\n        // then\n        resultActions\n                .andExpect(status().isOk())\n                .andExpect(content().string(\"안녕 null\"));\n\n    }\n}\n```\n\n테스트 코드입니다.  \n테스트는 통과과 되겠지만 결과 데이터는 안녕 null 입니다.  \nname 이 null 이 되면 안될것 같습니다.\n\n코드를 고쳐보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotNull(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private String name;\n\n    public String getMessage() {\n        return String.format(\"hello %s\", name);\n    }\n}\n```\n\n(1) HelloRequest 에 @NotNull 을 추가합니다.\n\n다시 수행하면 예상과 달리 또 통과가 되는데요.  \n이유는 validation 어노테이션을 체크할수 있는 장치가 추가로 필요하기 때문입니다.\n\n```java\npublic class ValidationApplication {\n    \n    // ...\n    @GetMapping(\"/hello\")\n    public String helloName(@Valid HelloRequest helloRequest) { // (1)\n\n        return helloRequest.getMessage();\n    }\n    // ...\n}\n```\n\n(1) @Valid 어노테이션을 추가하였습니다.\n\n다시 수행하면 예상처럼 테스트가 실패가 됩니다.  \n테스트를 성공시키도록 수정해보겠습니다.\n\n```java\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\nimport org.springframework.test.web.servlet.MockMvc;\nimport org.springframework.test.web.servlet.MvcResult;\nimport org.springframework.test.web.servlet.ResultActions;\nimport org.springframework.validation.BindException;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.tuple;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@WebMvcTest\nclass HelloControllerTest {\n\n    // ...\n    \n    @Test\n    @DisplayName(\"hello 컨트롤러에 파라미터를 전달 안하면 name validation 이 작동한다\") // (1)\n    void helloTest1() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n        );\n\n        // then\n        MvcResult mvcResult = resultActions\n                .andExpect(status().isBadRequest())\n                .andReturn();\n\n        assertThat(((BindException) mvcResult.getResolvedException()).getBindingResult().getFieldErrors()) // (2)\n                .extracting(\"field\", \"defaultMessage\")\n                .containsExactlyInAnyOrder(\n                        tuple(\"name\", \"이름은 빈값일 수 없습니다.\")\n                );\n    }\n}\n```\n\n(1) 테스트 이름을 변경합니다.  \n(2) 바인딩 에러를 잡아서 검증합니다.\n\n이제 통과를 할것입니다.  \n우리가 원하던대로 null 을 막았습니다.\n\nname 에 빈값이 들어가면 어떻게 될까요?  \n저는 빈값도 예외가 나오길 원합니다.\n\n테스트를 추가해보겠습니다.\n\n```java\n\n@WebMvcTest\nclass HelloControllerTest {\n    \n    // ...\n    \n    @Test\n    @DisplayName(\"hello 컨트롤러에 name 값을 빈값으로 전달하면 name validation 이 작동한다\")\n    void helloTest2() throws Exception {\n\n        // when\n        ResultActions resultActions = mvc.perform(get(\"/hello\")\n                .param(\"name\", \"\") // (1)\n        );\n\n        // then\n        MvcResult mvcResult = resultActions\n                .andExpect(status().isBadRequest())\n                .andReturn();\n\n        assertThat(((BindException) mvcResult.getResolvedException()).getBindingResult().getFieldErrors())\n                .extracting(\"field\", \"defaultMessage\")\n                .containsExactlyInAnyOrder(\n                        tuple(\"name\", \"이름은 빈값일 수 없습니다.\")\n                );\n    }\n}\n```\n\n(1) 먼저 작성한 테스트와 동일하지만 파라미터로 name 이 추가되었습니다.\n\n다시 수행하면 예상과 다르게 status 가 isOk 가 되면서 테스트가 실패하게 됩니다. 우리는 @NotNull 을 넣었는데 왜 통과가 되는것일까요?\n\nNotNull 의 javaDoc 을 보면\n\n> The annotated element must not be null. Accepts any type.\n\n이렇게 되어있습니다.  \nnull 만 체크하는용도입니다.\n\n## NotBlank\n\n코드를 수정해보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotBlank(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private String name;\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n```\n\n(1) @NotBlank 로 변경해보겠습니다.\n\n테스트를 재수행해보면 통과하는것을 알 수 있습니다.\n\nNotBlank 의 javaDoc 을 보면\n\n> The annotated element must not be null and must contain at least one non-whitespace character.  \n> Accepts CharSequence.\n\n이렇게 되어있습니다.  \nNotBlank 는 null 과 빈문자열을 체크하네요.\n\n## NotEmpty\n\n그동안 api 는 안녕 철수. 안녕 영희 같이 한명을 대상으로 했습니다.\n\n근데 저는 안녕 철수, 영희 처럼 2명을 대상으로 하고 싶어졌습니다.\n\n아래처럼 변경해보죠.\n\n```java\npublic static class HelloRequest {\n\n    @NotBlank(message = \"이름은 빈값일 수 없습니다.\")\n    private List<String> name; // (1)\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n```\n\n리스트로 변경해봅니다.  \n테스트를 재수행하면 아래와 같은 오류를 내뿜으면서 다 깨집니다.\n\n```\nNo validator could be found for constraint 'javax.validation.constraints.NotBlank' validating type 'java.util.List<java.lang.String>'. Check configuration for 'name'\n```\n\nNotBlank 를 List 에 쓸수 없다 라고 나오네요.\n\n다시 코드를 변경해보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotNull(message = \"이름은 빈값일 수 없습니다.\") // (1)\n    private List<String> name;\n\n    public String getMessage() {\n        return String.format(\"안녕 %s\", name);\n    }\n}\n```\n\n(1) NotNull 로 다시 변경했습니다.\n\n테스트를 재수행하니 helloTest1은 통과되고 helloTest2는 isOk를 내보내면서 실패했네요.\n\n@NotNull 로는 빈배열을 체크할수 없습니다.\n\n코드를 수정해보겠습니다.\n\n```java\npublic static class HelloRequest {\n\n    @NotEmpty(message = \"이름은 빈값일 수 없습니다.\") // (1) \n    private List<String> name;\n\n    public String getMessage() {\n        return String.format(\"hello %s\", name);\n    }\n}\n```\n\n(1) NotEmpty 로 변경했습니다.\n\n테스트를 재수행하니 통과되었습니다.\n\nNotEmpty 의 javaDoc 을 보면\n\n> The annotated element must not be null nor empty.  \n> Supported types are:    \n> CharSequence (length of character sequence is evaluated)  \n> Collection (collection size is evaluated)  \n> Map (map size is evaluated)  \n> Array (array length is evaluated)\n\n이렇게 되어있습니다.    \nNotEmpty 는 null 과 비어있는지 체크를 합니다.\n\n## 결론\n\n검증하려는 필드가 List 인가?\n\nyes → @NotEmpty\n\nno → 아래문항으로\n\n검증하려는 필드가 String 인가?\n\nyes → @NotBlank\n\nno → @NotNull\n\n읽어주셔서 감사합니다."},{"id":"1","title":"첫 블로그","description":"2021년 블로그를 시작과 인사말","date":"2021. 01. 01.","category":["기타"],"content":"\n2021년을 맞이하여 블로그를 꾸준히 운영을 해보려합니다.\n\n제가 필요한 기술들과   \n회사에서 접했던 문제들을 공유하려 합니다.\n\n일단 블로그는 next 로 틀만 만들고 차츰차츰 꾸밀거에요.\n\n블로그를 꾸미는 과정도 시리즈로 제공을 해볼게요.\n\n방문해주셔서 감사합니다."}],"categories":[{"id":"기타","count":1},{"id":"Bean Validation","count":1},{"id":"Spring","count":1},{"id":"Java","count":2},{"id":"Lombok","count":1}]},"__N_SSG":true}